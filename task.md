# Что нужно сделать

В этом задании мы примерим на себя амплуа архитектора системы и спроектируем базовые абстрактные классы для «Телеграфа», разработку которого мы начали в предыдущих модулях. Ранее вы реализовали класс «Текст» — этот класс мы не будем делать абстрактным. Однако есть ряд других сущностей, которые ранее для простоты не выделялись. Пришло время это исправить. Ниже приведена архитектурная схема «Телеграфа». Бежевые квадраты — это обычные классы, а голубые — абстрактные.

Выделим три абстракции:

- Пользователь — может быть автором, либо администратором.

- Хранилище — в дальнейшем мы реализуем возможность хранить тексты в базе данных и в виде файлов.

- Представление — интерфейс системы для пользователя и для администратора.

В этом задании мы будем описывать только абстрактные классы, без их реализации.

1. Создайте абстрактный класс для хранилища `Storage`. Пусть данный класс содержит следующие абстрактные методы:

- `create` — создать объект в хранилище. Метод получает на вход объект, который нужно сохранить, и после сохранения возвращает уникальный идентификатор;

- `read` — получить объект из хранилища. Метод принимает на вход `id` или `slug` (любое из значений) объекта и возвращает объект;

- `update` — обновить существующий объект в хранилище. Метод принимает на вход три параметра: `id` или `slug` (любое из значений) существующего объекта и сам обновлённый объект, который нужно сохранить;

- `delete` — удалить объект из хранилища. Метод принимает на вход id или slug объекта, который нужно удалить из хранилища;

- `list` — возвращает массив всех объектов в хранилище.

2. Создайте абстрактный класс для представления `View`. Этот класс должен содержать поле `$storage`, которому будет присвоен объект одного из дочерних классов `Storage`. Присвоение нужно реализовать в конструкторе, передав объект подкласса `Storage` в качестве параметра конструктора.

Пусть класс `View` содержит следующие абстрактные методы:

- `displayTextById` — вывести текст, принимает `id` в качестве параметра;
- `displayTextByUrl` — вывести текст, принимает `url` в качестве параметра.

3. Создайте абстрактный класс `User`. Пусть данный класс содержит поля:

- `$id` — уникальный идентификатор (целое число);
- `$name` — имя;
- `$role` — название роли (автор или администратор);
- и абстрактный метод `getTextsToEdit`, который выводит список текстов, доступных пользователю для редактирования.

4. Реализуем класс «Файл» (`FileStorage`) для абстрактного класса Storage.

5. Реализуем метод `create` — сохраняет сериализованный объект класса `TelegraphText`. Имя файла должно соответствовать полю `$slug` (объекта класса `TelegraphText`) + `_` + текущая дата. Если файл существует (для проверки используйте `file_exists`), то к имени файла добавьте `_1`. Если и такой файл существует — `_2`, и так до тех пор, пока имя файла не окажется уникальным. Перед тем, как записывать объект класса `TelegraphText` в файл, переопределите его поле `slug` в соответствии с именем файла. Для `FileStorage` метод `create` возвращает значение `slug`.

6. `Read` — возвращает объект класса `TelegraphText`. Используйте `slug` для поиска соответствующего файла.

7. `Update` — используйте slug для поиска соответствующего файла. Не забывайте сериализовать объект перед сохранением.

8. `Delete` — используйте slug для поиска соответствующего файла.

9. `List` — получите список файлов в директории, извлеките из них объекты класса `TelegraphText` (с помощью десериализации) и положите в массив. Метод `list` возвращает массив объектов класса `Text`. Для сканирования директории используйте встроенную функцию `scandir`.

10. Выполните по желанию: попробуйте в методах `loadText` и `storeText` класса `TelegraphText` использовать объект класса `FileStorage`. Сам объект передайте в качестве параметра конструктора класса `TelegraphText`.

11. Сделайте коммит ваших изменений с помощью `Git` и отправьте коммит в репозиторий.
